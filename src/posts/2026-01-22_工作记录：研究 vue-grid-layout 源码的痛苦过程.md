---
id: c2a85155-d9a6-4822-b17e-f6871341cbb8
title: 工作记录：研究 vue-grid-layout 源码的痛苦过程
createTime: 2026-01-22
updateTime:
categories: 工作记录, 前端组件
tags: vue-grid-layout
series: 自研网格布局系统
description: 因 vue-grid-layout 功能受限，我决定参考它自研 Grid 组件。发现其源码逻辑混乱；在处理drag和resize的过程中，经历了无法调试、反复回档的折磨，记录下这段耗时近两月的技术挣扎。
---

> 本文主要记录了这两个月研究 vue-grid-layout 源码过程中的各种坑，以及那些让人崩溃的瞬间（纯粹是想给这份痛苦留个档）。至于具体的代码和算法实现细节，我会在下一篇文章里详细展开。

## 为什么要自己开发？

因为现有的 `vue-grid-layout` 不支持项目的新功能（页边距和组件间隙），之前尝试过 dirty hack，但最终以失败告终（详见本系列前两篇文章）。这是两年前的事情了。

现在工期相对宽裕，公司决定让我通过“造轮子”的方式彻底解决这个问题。

## 开发目标：

- 支持分别设置页边距和组件间隙（原组件是由prop.margin统一控制，无法实现页边距<组件间隙的效果）
- 解决 yMargin 变化时，组件高度骤变的问题
- 完美兼容旧版数据
- 交互体验尽量与原组件保持一致

## 开发过程

### 1. 研究 vue-grid-layout 源码

最省力、直接的方法自然是修改 `vue-grid-layout` 的源码来实现目标。虽然我不认为能这么轻易就实现。但是我也觉得，研究它的源码是一个正确的开始，毕竟我在这个领域没什么经验。

### 2. 环境兼容性天坑（Node 版本冲突）

下载源码后，光是启动项目就费了老大劲。很是折腾了一番，过程不提了，最终发现它要求 Node 版本不能超过 14。

但是我们项目的 Node 版本是 22，两个版本跨度巨大，导致：

- **Node 14**：能启动 `vue-grid-layout`，但带不动我们的项目。
- **Node 22**：能启动我们的项目，但不能启动 `vue-grid-layout`

在自研组件的这两个月里，我还得兼顾主项目的日常维护（比如修个紧急 Bug 之类的）。这就导致我必须在两个 Node 版本之间频繁“反复横跳”，这种环境切换带来的琐碎和烦躁感简直是精神折磨。所以我决定：必须尽快把它的源码也彻底翻新到 Node 22 下！

考虑到直接在旧源码仓库里升级配置的成本太高，我决定不在旧环境里无谓挣扎，直接采取最干脆的办法——只把核心代码“带走”。

### 3. 配置老旧：VSCode 不识别 @flow

项目里虽然用了 @flow，却找不到配置文件。即便专门装了 VSCode 的 Flow 插件，代码依然满屏报红。虽然运行不受影响，但编辑器里那密密麻麻的报错提示确实干扰开发。

我不愿意把精力浪费在给旧项目升级环境这种碎事上，既然不影响运行，也就先忍了（反正我后续计划也是要彻底去掉 Flow 的，现在修配置性价比较低）。

我推测，这项目的架构早早就定下来了，后续几年只是在机械地更新功能，底层的框架配置一直没人去动，导致这套体系就这么一路“凑合”到了现在。

### 4. 瘦身：获得精简版本

源码内容杂乱，可读性差。

我根据我们项目的实际需求，逐个剔除未用到的属性和冗余代码。这是一个极其考验耐心和精力的过程，需要高度集中注意力以防误删。在这个过程中，我也发现源码质量参差不齐、风格不统一，估计是多年来多人参与维护、且审核标准不一导致的。

### 5. 迁移至 Demo 库

完成初步清理后，我将代码搬到了一个干净的、依赖环境（Node, Vue, Vite）与我们项目完全一致的新库中。然后，我把它源码里的 @flow 全手工改成了js。

迁移中，因为node版本不同，所以依赖库（`element-resize-detector`和`interactjs`）的安装、引用方式都和原始库里不同，这里不细说了。

适配完引用方式并测试通过后，我终于可以在 Node 22 环境下愉快地(?)研究源码，不用再来回切换版本了。

### 6. 给源码“动手术”，令人心惊的代码质量

研究的过程就是一边读、一边优化它的代码，不断循环往复。老实说，源码的代码质量低得让人心惊。举几个例子：

###### 事件流混乱

有的事件注册在父组件，有的又在子组件，这种职责划分完全摸索不出规律，导致追踪一个简单的交互逻辑要在文件间来回跳跃。

###### 命名与实际作用存在偏差

代码中会出现命名误导的现象。比如函数名暗示的是功能 A，实际逻辑却是功能 B。这种不一致让我不能相信任何函数名、变量名或者注释，必须强迫自己进入每个函数体去确认其真实意图。

###### 伪装成“纯函数”的逻辑陷阱

有些函数的注解写着：接收 layout 并返回修改后的 layout。从这种写法来看，直觉上会认为它是一个不改动原数据的纯函数，返回的是处理后的新副本。

但实际上，它是在函数内部直接对传入的对象进行了修改，最后 return 出来的其实还是指向原对象的同一引用。

而在调用这些函数时，代码里又写成了 `layout = fn(layout)`。这种写法极具误导性——它在形式上完全符合“生成新引用”的习惯，实际上却是在原地操作数据。迷惑性拉满！

###### 复用靠“复制粘贴”

部分逻辑存在直接复制粘贴的情况。相同长段代码在多处出现，没有进行公共复用的抽象。

（这种“屎山”的成因，我猜测是由于多年来项目缺乏统一的架构维护，且 PR 审核门槛较低。每个人都只想尽快塞进功能，没人对底层的一致性负责，导致代码质量逐渐失控。）

### 7. 调试地狱：高频事件与连锁碰撞

开发中最痛苦的莫过于调试 Resize 和 Drag 效果。它们都是高频连续触发的事件，根本无法通过断点定位。即便用 console.log，也很难在海量日志中捕捉到出 Bug 的那一瞬间。

更难处理的是“连环套连环”的逻辑：在高频事件中嵌套着复杂的布局重排。比如向下拽动 A 组件，会瞬间触发算法去计算连锁碰撞——A 撞到 B，B 又挤走 C。这种高频触发与连锁位移交织在一起，一旦某个边界情况效果不对，极难拆解到底是哪一环的逻辑出了偏差。

### 8. 边界情况与大回档

布局、组件数量、拖拽方向的不同组合都会产生不同的结果。
为了避免修改时的误操作，我每次修改都极其谨慎，但很多极端边界问题依然防不胜防。经常会出现这种情况：**改了一点东西 谨慎测试 没发现问题 继续改 突然发现某个效果崩了！**

最绝望的是，撤回最近一次修改，效果依然是坏的。这意味着问题可能出在更早之前的某次改动中。由于调试难度太大，代码也看不出破绽，我只能认输，直接“大回档”重来。
