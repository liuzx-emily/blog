---
id: be283ade-a011-47c0-8c46-9e0716a49dcd
title: pnpm 安装后 node_modules 是什么结构？为什么 webpack 不识别 pnpm 安装的包？
createTime: 2024-04-23
updateTime: 2024-04-23
categories: 底层工具
tags: pnpm
description: 本文研究使用 pnpm 安装依赖后 node_modules 下是什么结构，并总结 pnpm 的安装策略。最后说明为什么 webpack 无法识别 pnpm 安装的结构。
---

本篇研究：使用 pnpm 安装依赖时，node_modules 下是什么结构

---

## 回顾

### npm@3 之前：依赖树

![在这里插入图片描述](../post-assets/2ba5ddf6-1975-4e77-95c2-7b52798964b5.png)

缺点：

- frequently packages were creating too deep dependency trees, which caused long directory paths issue on Windows
- packages were copy pasted several times when they were required in different dependencies

### npm@3 和 yarn：扁平化

![在这里插入图片描述](../post-assets/5ecad514-cd36-4cd8-9203-e1c2dd9d3baf.png)
缺点：

- modules can access packages they don’t depend on
- the algorithm of flattening a dependency tree is pretty complex

---

## 测试 pnpm 效果

### yalc

为了方便看效果，我打算自己建几个 npm 包测试。

我并不想真的发布 npm 包，所以使用 [yalc](https://github.com/wclr/yalc) 模拟。折腾了一番，成功用 yalc 发布、安装 lib 后，发现自己的行为很愚蠢。。。因为使用这个 lib 时，要用 `yalc add xxx` 来安装，安装的逻辑是 yalc 的逻辑，不是 pnpm 的。所以这种方法不能测试出 pnpm 安装包的效果！STUPID!!!

还是老实发布 lib 吧

### publish library

参考[《在 npm 上发布包 npm publish》](https://blog.csdn.net/tangran0526/article/details/139620788)，创建三个包 a b c 并发布，依赖关系为：a 依赖 b，b 依赖 c，c 无依赖

### test-project

新建文件夹 test-project，`npm init -y`

安装 a ` pnpm i lilytest-lib-a`：

![在这里插入图片描述](../post-assets/9424d570-08e0-4d49-8a27-13bc17386c6d.png)
以 `node_modules/lilytest-lib-a` 为例说明。它是一个链接，真实路径为 `.pnpm/lilytest-lib-a@1.1.0/node_modules/lilytest-lib-a`。使用 dir 可以看到：

![在这里插入图片描述](../post-assets/286fc763-e984-440f-aa0d-9a06ca7f8417.png)

安装 a 和 b：

![在这里插入图片描述](../post-assets/d9d3759c-158c-4915-95aa-e7e7ee9fe065.png)
和之前相比，只多了 node_modules/lilytest-lib-b，链接到 `.pnpm/lilytest-lib-b@1.1.0/node_modules/lilytest-lib-b`

---

## 总结

结合官网说明，总结一下 pnpm 的安装流程：

### 第一步：在 .pnpm 下安装真实依赖

在 `node_modules/.pnpm` 下安装所有 package，无论直接、间接、间间接、间间间接、间间间...接的。放在`node_modules/.pnpm/<name>@<version>/node_modules/<name>`中。这些是 node_modules 下唯一的“真实”文件

解释一下：为什么最后还要多套一层 node_modules？

- **allow packages to import themselves.** `foo` should be able to `require('foo/package.json')` or `import * as package from "foo/package.json".`
- **avoid circular symlinks.** Dependencies of packages are placed in the same folder in which the dependent packages are. For Node.js it doesn't make a difference whether dependencies are inside the package's node_modules or in any other node_modules in the parent directories.

### 第二步：在 .pnpm 下链接依赖

比如，将 .pnpm/a/node_modules 下的 b 链接到 .pnpm/b/node_modules/b：
将 .pnpm/b/node_modules 下的 c 链接到 .pnpm/c/node_modules/c：

![在这里插入图片描述](../post-assets/024f333a-8ff5-4dae-8b25-e50e47d0baf0.png)

### 第三步：在 node_modules 下链接直接依赖

将 node_modules 下的 a 和 b 链接到 .pnpm 下对应位置

![在这里插入图片描述](../post-assets/483cd752-f3af-4a54-86b1-e18fcbeff11e.png)

参考阅读：

- [Symlinked node_modules structure](https://pnpm.io/symlinked-node-modules-structure)

### 个人理解

pnpm 将所有直接的、间接的依赖都平铺放在 `node_modules/.pnpm` 下，其实是和 yarn 同样采用了**扁平化**策略。不同之处在于：yarn 是放在 node_modules 下，导致间接依赖也暴露给外界了。而 pnpm 是放在 `node_modules/.pnpm` 下，所有依赖都“保护”起来了，外界不可访问。

但是 pnpm 要把直接依赖暴露给外部，所以 pnpm 又在 node_modules 下放了所有直接依赖。但它们都不是实体，都 symlink 到 .pnpm 下对应的位置。

---

## old-school webpack

本篇文章的起因就是 webpack 不认 pnpm 的路径，终于说回这个问题了。

[webpack Problems with pnpm and the way loaders are resolved](https://github.com/webpack/webpack/issues/5087)

> We have issues in lots of applications because webpack can't resolve packages in the node_modules created by pnpm. I think it is because webpack doesn't resolve dependencies the way Node does. Node resolves requires from the real path of a module. That is why the symlink approach pnpm uses works with all Node apps. However, it seems to confuse webpack and some other tools like browserify and eslint.
