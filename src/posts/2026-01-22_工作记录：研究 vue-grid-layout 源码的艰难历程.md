---
id: c2a85155-d9a6-4822-b17e-f6871341cbb8
title: 工作记录：研究 vue-grid-layout 源码的艰难历程
createTime: 2026-01-22
updateTime:
categories: 工作记录, 前端组件
tags: vue-grid-layout
series: 自研网格布局系统
description: 因为 vue-grid-layout 无法满足需求，我决定参考它自研 Grid 组件。这两个月是一场彻底的“受难记”：经历了 Node 版本频繁切换的内耗、源码逻辑混乱的折磨、Composition API 改写时的监听陷阱，以及高频交互下无法调试、只能反复“大回档”的绝望。本文不谈具体实现，只记录这段真实的研发挣扎。
---

## 为什么要自己开发？

因为现有的 `vue-grid-layout` 不支持项目的新功能（页边距和组件间隙），之前尝试过 dirty hack，但最终以失败告终（详见本系列前两篇文章）。这是两年前的事情了。

现在工期相对宽裕，公司决定让我通过“造轮子”的方式彻底解决这个问题。

## 开发目标：

- 支持分别设置页边距和组件间隙（原组件是由prop.margin统一控制，无法实现页边距<组件间隙的效果）
- 解决 yMargin 变化时，组件高度骤变的问题
- 完美兼容旧版数据
- 交互体验尽量与原组件保持一致

## 开发过程

### 动机：从研究源码开始

虽然我决定自研，但最省力、最直接的方法显然是先研究 `vue-grid-layout` 的源码。毕竟我在这个领域没什么经验，研究成熟组件的实现逻辑是一个正确的开始。

###### 刚上手就卡在了 Node 版本和 Flow 报错上

下载源码后，光是启动项目就费了老大劲。折腾了很久才发现，这项目的 **Node 版本不能超过 14**。但麻烦的是，我们自己项目的 Node 版本是 22，两个版本跨度巨大。

- **Node 14**：能启动 `vue-grid-layout`，但不能启动我们的项目。
- **Node 22**：能启动我们的项目，但不能启动 `vue-grid-layout`

在自研组件的这两个月里，我还得兼顾主项目的日常维护（比如紧急修bug）。这就导致我必须在两个 Node 版本之间**频繁“反复横跳”**，这种环境切换带来的琐碎感简直是精神折磨。

除了版本问题，项目配置也极其老旧。代码里虽然用了 `@flow`，却根本找不到配置文件。即便我装了 VSCode 的 Flow 插件，代码依然**满屏报红**。虽然不影响运行，但在密密麻麻的报错下看逻辑真的很干扰开发。当时我不想给旧项目修环境，只能先强忍着恶心“带病”运行了。

我推测，这项目的架构早早就定下来了，后续几年只是在机械地更新功能，底层的框架配置一直没人去动，导致这套体系就这么一路“凑合”到了现在。

### 强行给源码“瘦身”并发现一堆代码问题

源码内容多且乱，可读性差。因为我最终的目标是自研，所以没必要全盘接收它的逻辑。我开始根据我们项目的需求，逐个剔除那些用不到的属性和冗余代码。这是一个非常考验耐心和精力的过程，我必须高度集中注意力，生怕一不小心误删了某个核心逻辑。

在精简的过程中，我进入了一个“一边读、一边优化”的循环。但也正是因为看得深入了，我才发现这套源码的代码质量低得让人心惊：

- **事件流极其混乱**：有的事件注册在父组件，有的又塞在子组件，这种职责划分完全没规律。追踪一个交互逻辑需要在文件之间来回跳跃，非常痛苦。
- **命名完全是误导**：经常会出现函数名暗示功能 A，点进去看实际逻辑却是功能 B 的情况。导致我后来根本不敢相信任何注释或变量名，必须强迫自己看每一行函数体去确认它的真实意图。
- **伪装成“纯函数”的陷阱**：有些函数看起来是接收 layout 并返回新副本，形式上非常符合“不修改原数据”的习惯，但实际上它在内部直接改了传入的对象引用。这种写法极具误导性，迷惑性拉满。
- **大量重复的“复制粘贴”**：长段的逻辑在多处出现，完全没有公共复用的抽象。

我推测是因为这个项目维护了很多年，中间参与的人太多且审核标准不一，每个人都只想赶紧塞进新功能，导致底层的一致性彻底失控，最后堆成了这坨“屎山”。

### 为了不反复切 Node，决定彻底搬家

既然旧环境的配置这么坑，我也没必要在里面死磕了。考虑到我还一直要兼顾主项目的维护，我决定采取最干脆的办法：**不折腾旧环境，直接把核心代码“带走”**。

我创建了一个干净的 Demo 库，把 Node、Vue、Vite 等环境配置得跟我们现在的项目完全一致。然后，我开始把精简后的源码一点点搬过来：

- **手工“去 Flow 化”**：搬运过程中，我把代码里的 `@flow` 全手工改成了 js
- **适配依赖库引用**：因为 Node 版本变了，一些底层的依赖库（比如 `element-resize-detector` 和 `interactjs`）的安装和引用方式都跟原始库里不一样了。

费了这一番功夫后，我终于可以在 Node 22 环境下正常跑它的源码了。再也不用为了修主项目的一个 Bug 而去频繁切换 Node 版本。

### 改写 Composition API 时的“惊吓”与优化

为了让代码更现代，也为了更彻底地理解逻辑，我决定把原先的 Option API 全部升级成 Composition API。

我没有直接在原文件里改，因为代码体量实在太大，一旦改错地方根本没法定位。我采取了最笨也最稳妥的方法：**创建一个新文件，从 0 开始把源码的内容一点点挪过来**。在这个过程中，我不仅是在搬代码，更是在强迫自己去啃每一行逻辑并进行优化。

就在这个过程中，我撞到了 Vue 2.7 带来的一个巨大“惊喜”：**watch 的陷阱**。

###### 致命的无限循环（Infinite Loop）

原本在 `vue-grid-layout` 里，新增或删除布局项可以通过 `push` 或 `splice` 操作 `prop.layout`，组件内部会 `watch` 这个数组并调用 `compact` 进行重排。

可当我改成 Composition API 后，代码竟然直接陷入了**无限循环**。修复过程极其痛苦，最后通过对比测试才发现真相：

- **Option API 的 watch**：在 Vue 2.7 中，对数组的监听只能捕获到 `push`、`splice` 等方法的操作。
- **Composition API 的 watch**：不仅能监听到方法操作，**连数组内部项的属性修改也会被触发**。

而 `vue-grid-layout` 内部几乎所有的布局修改，都是在直接改动数组项的属性。这就导致：内部修改属性 -> 触发 watch -> 调用compact -> 再次修改属性 -> 再次触发 watch……

vue-grid-layout 源码居然利用了 vue2 中 Option API 的这个“可爱特性”来规避死循环，这种设计逻辑真是让人无语。这大概就是老旧代码在版本迭代中留下的隐形炸弹，如果不重构，根本发现不了坑这么深。

### 调试地狱：高频事件与连锁碰撞

开发中最痛苦的莫过于调试 Resize 和 Drag 效果。它们都是高频连续触发的事件，根本无法通过断点定位。即便用 `console.log`，也很难在海量日志中捕捉到出 Bug 的那一瞬间。

更难处理的是“连环套连环”的逻辑。在高频事件中嵌套着复杂的布局重排。比如向下拽动 A 组件，会瞬间触发算法去计算连锁碰撞——A 撞到 B，B 又挤走 C。这种高频触发与连锁位移交织在一起，一旦某个边界情况效果不对，极难拆解到底是哪一环的逻辑出了偏差。

###### 边界情况与大回档

布局、组件数量、拖拽方向的不同组合都会产生完全不同的结果。为了避免修改时的误操作，我每次修改都极其谨慎，但很多极端边界问题依然防不胜防。

经常会出现这种情况：**改了一点东西，谨慎测试没发现问题，继续改，突然发现某个效果崩了！**

最绝望的是，即使我撤回最近一次修改，效果依然是坏的。这意味着问题可能出在更早之前的某次改动中。由于调试难度太大，代码也看不出破绽，我只能认输，直接**“大回档”**重来。这种反复推倒重做的挫败感，是这两个月里最折磨人的环节。
